const lib = require("./lib");
const escodegen = require("escodegen");
const esprima = require("esprima");
const fs = require("fs");
const iconv = require("iconv-lite");
const path = require("path");
const {VM} = require("vm2");
const argv = require("./argv.js");

const filename = process.argv[2];

console.log(`Analyzing ${filename}`);
const sampleBuffer = fs.readFileSync(filename);
let encoding;
if (argv.encoding) {
	// console.log("Using argv encoding");
	encoding = argv.encoding;
} else {
	// console.log("Using detected encoding");
	encoding = require("jschardet").detect(sampleBuffer).encoding;
	if (encoding === null) encoding = "utf8";
	console.log(`The file seems to be encoded with ${encoding}.`);
}
const sampleSource = iconv.decode(sampleBuffer, encoding);
let code = fs.readFileSync(path.join(__dirname, "patch.js"), "utf8") + sampleSource;

if (code.match("<job") || code.match("<script")) { // The sample may actually be a .wsf, which is <job><script>..</script><script>..</script></job>.
	code = code.replace(/<\??\/?\w+( [\w=\"\']*)*\??>/g, ""); // XML tags
	code = code.replace(/<!\[CDATA\[/g, "");
	code = code.replace(/\]\]>/g, "");
}

function rewrite(code) {
	if (code.match("@cc_on")) {
		if (!argv["no-cc_on-rewrite"]) {
			console.log("    Replacing @cc_on statements (use --no-cc_on-rewrite to skip)...");
			code = code.replace(/\/\*@cc_on/g, "");
			code = code.replace(/@\*\//g, "");
		} else {
			console.log(
				`The code appears to contain conditional compilation statements.
If you run into unexpected results, try uncommenting lines that look like

    /*@cc_on
    <JavaScript code>
    @*/

`
			);
		}
	}

	if (!argv["no-rewrite"]) {
		console.log("Rewriting code...");
		if (argv["dumb-concat-simplify"]) {
			console.log("    Simplifying \"dumb\" concatenations (remove --dumb-concat-simplify to skip)...");
			code = code.replace(/'[ \r\n]*\+[ \r\n]*'/gm, "");
			code = code.replace(/"[ \r\n]*\+[ \r\n]*"/gm, "");
		}

		if (argv["preprocess"]) {
			console.log(`    Preprocessing with uglify-js v${require("uglify-js/package.json").version} (remove --preprocess to skip)...`);
			const result = require("uglify-js").minify(code, {
				compress: {
					passes: 3,
					/* Using sequences (a; b; c; -> a, b, c) provide any performance benefits,
					 * but it makes code harder to read. Therefore, this behaviour is disabled.
					 */
					sequences: false,
					unsafe: !!argv["unsafe-preprocess"],
				},
				output: {
					beautify: true,
					comments: true,
				},
			});
			if (result.error) {
				console.log("Couldn't preprocess with uglify-js:", result.error);
			} else {
				code = result.code;
			}
		}

		if (!argv["no-rewrite-prototype"]) {
			console.log("    Replacing `function A.prototype.B()` (use --no-rewrite-prototype to skip)...");
			// Replace `function X.prototype.y()` with `X.prototype.y = function()`
			code = code.replace(/function (\w+)\.prototype\.(\w+)/gm, "$1.prototype.$2 = function");
		}

		let tree;
		try {
			tree = esprima.parse(code);
		} catch (e) {
			console.log(e);
			console.log("");
			if (filename.match(/jse$/)) {
				console.log(
					`This appears to be a JSE (JScript.Encode) file.
Please compile the decoder and decode it first:

cc decoder.c -o decoder
./decoder ${filename} ${filename.replace(/jse$/, "js")}

`
				);
			} else {
				console.log(
					`This doesn't seem to be a JavaScript/WScript file.
If this is a JSE file (JScript.Encode), compile
decoder.c and run it on the file, like this:

cc decoder.c -o decoder
./decoder ${filename} ${filename}.js

`
				);
			}
			process.exit(-1);
			return;
		}

		if (argv["function-rewrite"]) {
			console.log("    Rewriting functions (remove --function-rewrite to skip)...");
			traverse(tree, function(key, val) {
				if (key !== "callee") return;
				if (val.autogenerated) return;
				switch (val.type) {
					case "MemberExpression":
						return require("./patches/this.js")(val.object, val);
					default:
						return require("./patches/nothis.js")(val);
				}
			});
		}

		if (!argv["no-typeof-rewrite"]) {
			console.log("    Rewriting typeof calls (use --no-typeof-rewrite to skip)...");
			traverse(tree, function(key, val) {
				if (!val) return;
				if (val.type !== "UnaryExpression") return;
				if (val.operator !== "typeof") return;
				if (val.autogenerated) return;
				return require("./patches/typeof.js")(val.argument);
			});
		}

		if (!argv["no-eval-rewrite"]) {
			console.log("    Rewriting eval calls (use --no-eval-rewrite to skip)...");
			traverse(tree, function(key, val) {
				if (!val) return;
				if (val.type !== "CallExpression") return;
				if (val.callee.type !== "Identifier") return;
				if (val.callee.name !== "eval") return;
				return require("./patches/eval.js")(val.arguments);
			});
		}

		if (!argv["no-catch-rewrite"]) { // JScript quirk
			console.log("    Rewriting try/catch statements (use --no-catch-rewrite to skip)...");
			traverse(tree, function(key, val) {
				if (!val) return;
				if (val.type !== "TryStatement") return;
				if (!val.handler) return;
				if (val.autogenerated) return;
				return require("./patches/catch.js")(val);
			});
		}

		// console.log(JSON.stringify(tree, null, "\t"));
		code = escodegen.generate(tree);

		// The modifications may have resulted in more concatenations, eg. "a" + ("foo", "b") + "c" -> "a" + "b" + "c"
		if (argv["dumb-concat-simplify"]) {
			console.log("    Simplifying \"dumb\" concatenations (remove --dumb-concat-simplify to skip)...");
			code = code.replace(/'[ \r\n]*\+[ \r\n]*'/gm, "");
			code = code.replace(/"[ \r\n]*\+[ \r\n]*"/gm, "");
		}

		console.log("Rewritten successfully.");
	}

	return code;
}
code = rewrite(code);
lib.logJS(code);

Array.prototype.Count = function() {
	return this.length;
};

const sandbox = {
	ActiveXObject,
	alert: (x) => {},
	console: {
		log: (x) => console.log(JSON.stringify(x)),
	},
	Enumerator: require("./emulator/Enumerator"),
	GetObject: require("./emulator/WMI").GetObject,
	JSON,
	location: new Proxy({
		href: "http://www.foobar.com/",
		protocol: "http:",
		host: "www.foobar.com",
		hostname: "www.foobar.com",
	}, {
		get: function(target, name) {
			switch (name) {
				case Symbol.toPrimitive:
					return () => "http://www.foobar.com/";
				default:
					return target[name.toLowerCase()];
			}
		},
	}),
	parse: (x) => {},
	rewrite: (code) => rewrite(lib.logJS(code)),
	ScriptEngine: () => {
		const type = "JScript"; // or "JavaScript", or "VBScript"
		console.log(`Notice: emulating a ${type} engine (in ScriptEngine)`);
		return type;
	},
	_typeof: (x) => x.typeof ? x.typeof : typeof x,
	WScript: new Proxy({}, {
		get: function(target, name) {
			if (typeof name === "string") name = name.toLowerCase();
			switch (name) {
				case Symbol.toPrimitive:
					return () => "Windows Script Host";
				case "tostring":
					return "Windows Script Host";

				case "arguments":
					return new Proxy((n) => `${n}th argument`, {
						get: function(target, name) {
							switch (name) {
								case "Unnamed":
									return [];
								case "length":
									return 0;
								case "ShowUsage":
									return {
										typeof: "unknown",
									};
								case "Named":
									return [];
								default:
									return new Proxy(
										target[name],
										{
											get: (target, name) => name.toLowerCase() === "typeof" ? "unknown" : target[name],
										}
									);
							}
						},
					});
				case "createobject":
					return ActiveXObject;
				case "echo":
					if (argv["no-echo"])
						return () => {};
					return (x) => {
						console.log("Script wrote:", x);
						console.log("Add flag --no-echo to disable this.");
					};
				case "path":
					return "C:\\TestFolder\\";
				case "sleep":
					// return x => console.log(`Sleeping for ${x} ms...`)
					return (x) => {};
				case "stdin":
					return new Proxy({
						atendofstream: {
							typeof: "unknown",
						},
						line: 1,
						writeline: (text) => {
							if (argv["no-echo"]) return;
							console.log("Script wrote:", text);
							console.log("Add flag --no-echo to disable this.");
						},
					}, {
						get: function(target, name) {
							name = name.toLowerCase();
							if (!(name in target))
								lib.kill(`WScript.StdIn.${name} not implemented!`);
							return target[name];
						},
					});
				case "quit":
					return () => {};
				case "scriptfullname":
					return "(ScriptFullName)";
				case "scriptname":
					return "sample.js";
				default:
					lib.kill(`WScript.${name} not implemented!`);
			}
		},
	}),
	WSH: "Windows Script Host",
};

const vm = new VM({
	timeout: (argv.timeout || 10) * 1000,
	sandbox,
});

vm.run(code);

function ActiveXObject(name) {
	// console.log(`New ActiveXObject: ${name}`);
	name = name.toLowerCase();
	if (name.match("winhttprequest"))
		return require("./emulator/XMLHTTP")();
	if (name.match("xmlhttp"))
		return require("./emulator/XMLHTTP")();
	if (name.match("dom")) {
		return {
			createElement: require("./emulator/DOM"),
			load: (filename) => {
				// console.log(`Loading ${filename} in a virtual DOM environment...`);
			},
		};
	}

	switch (name) {
		case "adodb.stream":
			return require("./emulator/ADODBStream")();
		case "adodb.recordset":
			return require("./emulator/ADODBRecordSet")();
		case "scriptcontrol":
			return require("./emulator/ScriptControl")();
		case "scripting.filesystemobject":
			return require("./emulator/FileSystemObject")();
		case "scripting.dictionary":
			return require("./emulator/Dictionary")();
		case "shell.application":
			return require("./emulator/ShellApplication")();
		case "wscript.network":
			return require("./emulator/WScriptNetwork")();
		case "wscript.shell":
			return require("./emulator/WScriptShell")();
		case "wbemscripting.swbemlocator":
			return require("./emulator/WBEMScriptingSWBEMLocator")();
		default:
			lib.kill(`Unknown ActiveXObject ${name}`);
			break;
	}
}

function traverse(obj, func) {
	const keys = Object.keys(obj);
	for (let i = 0; i < keys.length; i++) {
		const key = keys[i];
		const replacement = func.apply(this, [key, obj[key]]);
		if (replacement) obj[key] = replacement;
		if (obj.autogenerated) continue;
		if (obj[key] !== null && typeof obj[key] === "object")
			traverse(obj[key], func);
	}
}
